알고리즘 설계방법
먼저 현재 철수가 위치한 돌의 값 a와 직전에 점프한 거리 k를 선언한다.
만약 철수가 마지막 돌에 위치해있다면, true를 반환하고, 그렇지 않다면 false를 반환한다.
철수는 뒤로가지 않기 때문에 철수 앞에있는 돌중에 a+k+2, a+k+1, a+k, a+k-1, a+k-2이 존재한다면
철수는 앞에있는 돌로 점프를 한다.
a+k+2, a+k+1, a+k, a+k-1, a+k-2중에 존재하지 않는다면 함수를 종료한다.
철수가 마지막 돌에 위치해있다면, 탐색을 종료하고 true를 반환한다.
모든 경우의 수를 탐색했을 때 철수가 마지막 돌에 위치할 수 있다면 true를 반환하고, 그렇지 않다면 false를 반환하도록 한다.
만약 철수 다음에 있는 돌이 a+k+2 보다 크다면, 함수를 종료한다.
왜냐하면, 깊이우선탐색으로 탐색하던 철수가 위치한 돌이 a+k+2보다 크다면, 절대로 그 돌로 이동할 수 없기 때문이다.

correctess & effecifiency

Loop invariant : 철수는 항상 자신의 위치한 돌 앞에있는 돌들로만 이동한다.
Inductive Hypothesis : 길이가 i인 징검다리에서, 철수가 다리를 건널 수 있는지 알 수 있다면, i+1인 징검다리에서도 다리를 건널 수 있는지 확인할 수 있다. (i >= 2)
Basecase: 돌이 0, 1 이고 길이가 2인 징검다리에서 철수가 다리를 건널 수 있는지 알 수 있다.
Indective step : 길이가 i+1인 징검다리에서 철수가 현재 위치한 돌(i) 다음에 위치한 돌(i+1)의 값이 a+k+2, a+k+1, a+k, a+k-1, a+k-2중에 존재한다면 철수는 다리를 건널 수있다. 
(a는 돌의 값, k는 직전의 뛴 점프거리 값)
만약 존재하지 않는다면, 철수는 다리를 건널 수 없다.
Conclusion : 길이가 i + 1인 징검다리에서 철수는 다리를 건널 수 있는지 알 수 있다.

돌다리의 길이가 n이라고 할때, 철수는 다음 다리를 건너기 전, 자신이 위치를 찾는다. 이는 상수시간이 소요 된다 .
점프할 수 있는 돌이 존재하는지 확인하기 위해 n-(현재 철수의 위치)만큼 배열을 탐색한다. n-현재 철수의 위치 만큼 시간이 소요된다.
이 과정을 철수가 마지막 돌로 이동할 때까지 반복한다. 철수는 최대 모든 돌을 건너면서 이 과정을 반복한다. 

종합적인 시간복잡도는 O ( n * (c + n - c) ) = O(n^2) 라고 볼 수 있다.