1. 먼저 10000개의 pair형식 자료구조를 생성합니다. 10000개인 이유는 입력으로 주어질수 있는 배열의 최대 길이
pair의 first에는 주어진 정수 배열의 인자, second에는 그 인자가 호출된 횟수가 저장됩니다.
이때의 시간 복잡도는 n + n =>  O(n)입니다.
2. 그리고 이 배열을 mergesort를 사용하여 오름차순으로 정렬합니다.
mergesort의 시간복잡도는 O(nlogn)입니다.
3. 그후 pair의 (최대 길이 -k)의 first값을 출력하면 k번째 로 많이 많은 원소를 반환합니다.
최종적 시간복잡도는 O(nlogn)입니다.

Correctness & Efficency

Correctness
Inductive Hypothesis 
병합정렬은 정확하게 i길이의 배열을 정렬합니다. 
Base case
배열의 길이 1일때는 원소가 하나이기 때문에 그 자체로 정렬된 상태입니다. 
Inductive step
병합정렬이 길이 1부터 i까지의 배열에서 정상적으로 정렬했다고 가정했을때
길이 i+1의 리스트에서 병합 정렬을 실행하면 왼쪽과 오른쪽으로 나누어 1+i/2 길이의 머지소트를 재귀적으로 호출합니다. 
왼쪽배열과 오른쪽배열은 원래 배열의 왼쪽 절반과 오른쪽 절반에 있는 값을 정렬합니다. 
2개의 정렬된 배열이 주어지면 병합하여 정렬된 리스트를 반환합니다.

efficiency
pair를 선언하는데 O(1)이 선언됩니다.
첫 번째, 두번째 for문에서 O(n)의 시간복잡도가 소요됩니다.
mergesort에서 divide에서 O(1),  conquer에서 2T(n/2), merge에서 O(n)이 소요됩니다. 총 O(nlogn)이 정렬에 소요됩니다.
마지막 return에서 O(1)의 시간복잡도가 소요됩니다.
그래서 최종적 시간복잡도는 O(NlogN)으로 예상됩니다.